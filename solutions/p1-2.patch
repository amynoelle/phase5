diff -X pat -urpN pintos.orig/src/threads/synch.c pintos/src/threads/synch.c
--- pintos.orig/src/threads/synch.c	2004-09-19 21:29:53.000000000 -0700
+++ pintos/src/threads/synch.c	2004-09-27 16:50:14.000000000 -0700
@@ -330,3 +330,35 @@ cond_name (const struct condition *cond)
 
   return cond->name;
 }
+
+void
+latch_init (struct latch *latch, const char *name) 
+{
+  latch->released = false;
+  lock_init (&latch->monitor_lock, name);
+  cond_init (&latch->rel_cond, name);
+}
+
+void
+latch_acquire (struct latch *latch) 
+{
+  lock_acquire (&latch->monitor_lock);
+  if (!latch->released) 
+    {
+      cond_wait (&latch->rel_cond, &latch->monitor_lock);
+      ASSERT (latch->released); 
+    }
+  lock_release (&latch->monitor_lock);
+}
+
+void
+latch_release (struct latch *latch) 
+{
+  lock_acquire (&latch->monitor_lock);
+  if (!latch->released)
+    {
+      latch->released = true;
+      cond_signal (&latch->rel_cond, &latch->monitor_lock);
+    }
+  lock_release (&latch->monitor_lock);
+}
diff -X pat -urpN pintos.orig/src/threads/synch.h pintos/src/threads/synch.h
--- pintos.orig/src/threads/synch.h	2004-09-19 21:29:53.000000000 -0700
+++ pintos/src/threads/synch.h	2004-09-27 16:50:14.000000000 -0700
@@ -44,4 +44,16 @@ void cond_signal (struct condition *, st
 void cond_broadcast (struct condition *, struct lock *);
 const char *cond_name (const struct condition *);
 
+/* Latch. */
+struct latch 
+  {
+    bool released;              /* Released yet? */
+    struct lock monitor_lock;   /* Monitor lock. */
+    struct condition rel_cond;  /* Signaled when released. */
+  };
+
+void latch_init (struct latch *, const char *);
+void latch_acquire (struct latch *);
+void latch_release (struct latch *);
+
 #endif /* threads/synch.h */
diff -X pat -urpN pintos.orig/src/threads/thread.c pintos/src/threads/thread.c
--- pintos.orig/src/threads/thread.c	2004-09-26 14:15:17.000000000 -0700
+++ pintos/src/threads/thread.c	2004-09-27 16:51:03.000000000 -0700
@@ -80,6 +80,7 @@ thread_init (void) 
   init_thread (initial_thread, "main", PRI_DEFAULT);
   initial_thread->status = THREAD_RUNNING;
   initial_thread->tid = allocate_tid ();
+  sema_up (&initial_thread->can_die);
 }
 
 /* Starts preemptive thread scheduling by enabling interrupts.
@@ -148,6 +149,7 @@ thread_create (const char *name, int pri
   /* Initialize thread. */
   init_thread (t, name, priority);
   tid = t->tid = allocate_tid ();
+  list_push_back (&thread_current ()->children, &t->children_elem);
 
   /* Stack frame for kernel_thread(). */
   kf = alloc_frame (t, sizeof *kf);
@@ -224,16 +226,33 @@ thread_tid (void) 
 void
 thread_exit (void) 
 {
+  struct thread *t = thread_current ();
+  list_elem *e;
+
   ASSERT (!intr_context ());
 
 #ifdef USERPROG
   process_exit ();
 #endif
 
+  /* Notify our parent that we're dying. */
+  latch_release (&t->ready_to_die);
+
+  /* Notify our children that they can die. */
+  for (e = list_begin (&t->children); e != list_end (&t->children);
+       e = list_next (e)) 
+    {
+      struct thread *child = list_entry (e, struct thread, children_elem);
+      sema_up (&child->can_die); 
+    }
+
+  /* Wait until our parent is ready for us to die. */
+  sema_down (&t->can_die);
+
   /* Just set our status to dying and schedule another process.
      We will be destroyed during the call to schedule_tail(). */
   intr_disable ();
-  thread_current ()->status = THREAD_DYING;
+  t->status = THREAD_DYING;
   schedule ();
   NOT_REACHED ();
 }
@@ -270,6 +290,22 @@ thread_block (void) 
   thread_current ()->status = THREAD_BLOCKED;
   schedule ();
 }
+
+/* Waits for thread with tid CHILD_TID to die. */
+void
+thread_join (tid_t child_tid) 
+{
+  struct thread *cur = thread_current ();
+  list_elem *e;
+
+  for (e = list_begin (&cur->children); e != list_end (&cur->children); ) 
+    {
+      struct thread *child = list_entry (e, struct thread, children_elem);
+      e = list_next (e);
+      if (child->tid == child_tid) 
+        latch_acquire (&child->ready_to_die);
+    }
+}
 
 /* Idle thread.  Executes when no other thread is ready to run. */
 static void
@@ -335,6 +371,9 @@ init_thread (struct thread *t, const cha
   strlcpy (t->name, name, sizeof t->name);
   t->stack = (uint8_t *) t + PGSIZE;
   t->priority = priority;
+  latch_init (&t->ready_to_die, "ready-to-die");
+  sema_init (&t->can_die, 0, "can-die");
+  list_init (&t->children);
   t->magic = THREAD_MAGIC;
 }
 
diff -X pat -urpN pintos.orig/src/threads/thread.h pintos/src/threads/thread.h
--- pintos.orig/src/threads/thread.h	2004-09-26 14:15:17.000000000 -0700
+++ pintos/src/threads/thread.h	2004-09-27 16:50:14.000000000 -0700
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -89,6 +90,12 @@ struct thread
     uint8_t *stack;                     /* Saved stack pointer. */
     int priority;                       /* Priority. */
 
+    /* Members for implementing thread_join(). */
+    struct latch ready_to_die;          /* Release when thread about to die. */
+    struct semaphore can_die;           /* Up when thread allowed to die. */
+    struct list children;               /* List of child threads. */
+    list_elem children_elem;            /* Element of `children' list. */
+
     /* Shared between thread.c and synch.c. */
     list_elem elem;                     /* List element. */
 
