diff -urp -X pat src/threads/init.c~ src/threads/init.c
--- src/threads/init.c~	2005-03-30 10:26:02.000000000 -0800
+++ src/threads/init.c	2005-03-30 20:05:20.000000000 -0800
@@ -120,8 +120,11 @@ main (void)
   /* Run a user program. */
   if (initial_program != NULL)
     {
+      struct semaphore done;
+      sema_init (&done, 0, "done");
       printf ("\nExecuting '%s':\n", initial_program);
-      process_wait (process_execute (initial_program));
+      process_execute (initial_program, &done);
+      sema_down (&done);
     }
 #else
   /* Run the compiled-in test function. */
diff -urp -X pat src/threads/synch.c~ src/threads/synch.c
--- src/threads/synch.c~	2005-03-29 22:23:20.000000000 -0800
+++ src/threads/synch.c	2005-03-30 20:01:45.000000000 -0800
@@ -117,7 +117,7 @@ sema_self_test (void) 
   printf ("Testing semaphores...");
   sema_init (&sema[0], 0, "ping");
   sema_init (&sema[1], 0, "pong");
-  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
+  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema, NULL);
   for (i = 0; i < 10; i++) 
     {
       sema_up (&sema[0]);
diff -urp -X pat src/threads/test.c~ src/threads/test.c
--- src/threads/test.c~	2005-01-22 11:14:57.000000000 -0800
+++ src/threads/test.c	2005-03-30 20:03:11.000000000 -0800
@@ -93,7 +93,7 @@ test_sleep (int thread_cnt, int iteratio
       t->iterations = 0;
 
       snprintf (name, sizeof name, "thread %d", i);
-      thread_create (name, PRI_DEFAULT, sleeper, t);
+      thread_create (name, PRI_DEFAULT, sleeper, t, NULL);
     }
   
   /* Wait long enough for all the threads to finish. */
diff -urp -X pat src/threads/thread.c~ src/threads/thread.c
--- src/threads/thread.c~	2005-03-30 10:26:13.000000000 -0800
+++ src/threads/thread.c	2005-03-30 20:08:17.000000000 -0800
@@ -51,7 +51,8 @@ static void kernel_thread (thread_func *
 static void idle (void *aux UNUSED);
 static struct thread *running_thread (void);
 static struct thread *next_thread_to_run (void);
-static void init_thread (struct thread *, const char *name, int priority);
+static void init_thread (struct thread *, const char *name, int priority,
+                         struct semaphore *);
 static bool is_thread (struct thread *);
 static void *alloc_frame (struct thread *, size_t size);
 static void schedule (void);
@@ -78,7 +79,7 @@ thread_init (void) 
 
   /* Set up a thread structure for the running thread. */
   initial_thread = running_thread ();
-  init_thread (initial_thread, "main", PRI_DEFAULT);
+  init_thread (initial_thread, "main", PRI_DEFAULT, NULL);
   initial_thread->status = THREAD_RUNNING;
   initial_thread->tid = allocate_tid ();
 }
@@ -88,7 +89,7 @@ thread_init (void) 
 void
 thread_start (void) 
 {
-  thread_create ("idle", PRI_DEFAULT, idle, NULL);
+  thread_create ("idle", PRI_DEFAULT, idle, NULL, NULL);
   intr_enable ();
 }
 
@@ -133,7 +134,8 @@ thread_print_stats (void) 
    Priority scheduling is the goal of Problem 1-3. */
 tid_t
 thread_create (const char *name, int priority,
-               thread_func *function, void *aux) 
+               thread_func *function, void *aux,
+               struct semaphore *completion)
 {
   struct thread *t;
   struct kernel_thread_frame *kf;
@@ -149,7 +151,7 @@ thread_create (const char *name, int pri
     return TID_ERROR;
 
   /* Initialize thread. */
-  init_thread (t, name, priority);
+  init_thread (t, name, priority, completion);
   tid = t->tid = allocate_tid ();
 
   /* Stack frame for kernel_thread(). */
@@ -245,6 +247,9 @@ thread_exit (void) 
 {
   ASSERT (!intr_context ());
 
+  if (thread_current ()->completion)
+    sema_up (thread_current ()->completion);
+
 #ifdef USERPROG
   process_exit ();
 #endif
@@ -342,7 +347,8 @@ is_thread (struct thread *t) 
 /* Does basic initialization of T as a blocked thread named
    NAME. */
 static void
-init_thread (struct thread *t, const char *name, int priority)
+init_thread (struct thread *t, const char *name, int priority,
+             struct semaphore *completion)
 {
   ASSERT (t != NULL);
   ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
@@ -353,6 +359,7 @@ init_thread (struct thread *t, const cha
   strlcpy (t->name, name, sizeof t->name);
   t->stack = (uint8_t *) t + PGSIZE;
   t->priority = priority;
+  t->completion = completion;
   t->magic = THREAD_MAGIC;
 }
 
diff -urp -X pat src/threads/thread.h~ src/threads/thread.h
--- src/threads/thread.h~	2005-03-30 10:26:13.000000000 -0800
+++ src/threads/thread.h	2005-03-30 20:03:11.000000000 -0800
@@ -92,6 +92,9 @@ struct thread
     /* Shared between thread.c and synch.c. */
     struct list_elem elem;              /* List element. */
 
+    /* Completion semaphore. */
+    struct semaphore *completion;
+
 #ifdef USERPROG
     /* Owned by userprog/process.c. */
     uint32_t *pagedir;                  /* Page directory. */
@@ -107,7 +110,8 @@ void thread_tick (void);
 void thread_print_stats (void);
 
 typedef void thread_func (void *aux);
-tid_t thread_create (const char *name, int priority, thread_func *, void *);
+tid_t thread_create (const char *name, int priority, thread_func *, void *,
+                     struct semaphore *);
 
 void thread_block (void);
 void thread_unblock (struct thread *);
diff -urp -X pat src/userprog/process.c~ src/userprog/process.c
--- src/userprog/process.c~	2005-03-30 20:06:20.000000000 -0800
+++ src/userprog/process.c	2005-03-30 20:06:27.000000000 -0800
@@ -21,11 +21,10 @@ static thread_func execute_thread NO_RET
 static bool load (const char *cmdline, void (**eip) (void), void **esp);
 
 /* Starts a new thread running a user program loaded from
-   FILENAME.  The new thread may be scheduled (and may even exit)
-   before process_execute() returns.  Returns the new process's
-   thread id, or TID_ERROR if the thread cannot be created. */
+   FILENAME.  The new thread may be scheduled before
+   process_execute() returns.*/
 tid_t
-process_execute (const char *filename) 
+process_execute (const char *filename, struct semaphore *completion) 
 {
   char *fn_copy;
   tid_t tid;
@@ -38,7 +37,8 @@ process_execute (const char *filename) 
   strlcpy (fn_copy, filename, PGSIZE);
 
   /* Create a new thread to execute FILENAME. */
-  tid = thread_create (filename, PRI_DEFAULT, execute_thread, fn_copy);
+  tid = thread_create (filename, PRI_DEFAULT, execute_thread, fn_copy,
+                       completion);
   if (tid == TID_ERROR)
     palloc_free_page (fn_copy); 
   return tid;
diff -urp -X pat src/userprog/process.h~ src/userprog/process.h
--- src/userprog/process.h~	2005-03-30 15:09:53.000000000 -0800
+++ src/userprog/process.h	2005-03-30 20:02:51.000000000 -0800
@@ -2,8 +2,9 @@
 #define USERPROG_PROCESS_H
 
 #include "threads/thread.h"
+#include "threads/synch.h"
 
-tid_t process_execute (const char *filename);
+tid_t process_execute (const char *filename, struct semaphore *);
 int process_wait (tid_t);
 void process_exit (void);
 void process_activate (void);
